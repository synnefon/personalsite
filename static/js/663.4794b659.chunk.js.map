{"version":3,"file":"static/js/663.4794b659.chunk.js","mappings":"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","sources":["shufflenator/shuffleWorker.js"],"sourcesContent":["// Self-contained web worker for shuffle computation.\n// All logic is inlined to avoid import issues in worker context.\n\n// --- Scorers ---\n\nfunction calcAverageNeighborDist(cards) {\n    const deckLen = cards.length;\n    let total = 0;\n    for (let idx = 0; idx < deckLen; idx++) {\n        let diff = cards[(idx + 1) % deckLen] - cards[idx];\n        if (diff < 0) diff += deckLen;\n        total += diff;\n    }\n    return total / deckLen;\n}\n\nfunction calcLocationDelta(cards) {\n    let total = 0;\n    for (let idx = 0; idx < cards.length; idx++) {\n        total += Math.abs(idx - cards[idx]);\n    }\n    return total / cards.length;\n}\n\nfunction calcShannonEntropy(cards) {\n    const deckLen = cards.length;\n    const counts = {};\n    for (let idx = 0; idx < deckLen; idx++) {\n        let diff = cards[(idx + 1) % deckLen] - cards[idx];\n        if (diff < 0) diff += deckLen;\n        counts[diff] = (counts[diff] || 0) + 1;\n    }\n    let entropy = 0;\n    for (const key in counts) {\n        const p = counts[key] / deckLen;\n        entropy += Math.abs(Math.log(p) * p);\n    }\n    return entropy;\n}\n\nconst SCORE_FUNCTION_MAP = {\n    \"SHANNON_ENTROPY\": calcShannonEntropy,\n    \"NEIGHBOR_DIST\": calcAverageNeighborDist,\n    \"LOCATION_DELTA\": calcLocationDelta,\n};\n\n// --- Shuffler ---\n\nfunction makeShuffledDeck(cardList, permutation, scoreType) {\n    return {\n        cardList,\n        permutation,\n        score: SCORE_FUNCTION_MAP[scoreType](cardList),\n        key: permutation.join(','),\n    };\n}\n\nfunction shuffle(pileSelector, deck, numPiles, scoreType) {\n    const piles = Array.from({ length: numPiles }, () => []);\n    for (let idx = 0; idx < deck.cardList.length; idx++) {\n        piles[pileSelector(idx)].unshift(deck.cardList[idx]);\n    }\n    return makeShuffledDeck(piles.flat(), [...deck.permutation, numPiles], scoreType);\n}\n\nfunction pileShuffle(deck, numPiles, scoreType) {\n    const cards = deck.cardList;\n    const len = cards.length;\n    const result = new Array(len);\n    const full = Math.floor(len / numPiles);\n    const remainder = len % numPiles;\n    let offset = 0;\n    const pileStart = new Array(numPiles);\n    const pileSize = new Array(numPiles);\n    for (let p = 0; p < numPiles; p++) {\n        pileStart[p] = offset;\n        pileSize[p] = p < remainder ? full + 1 : full;\n        offset += pileSize[p];\n    }\n    const writePos = new Array(numPiles);\n    for (let p = 0; p < numPiles; p++) {\n        writePos[p] = pileStart[p] + pileSize[p] - 1;\n    }\n    for (let idx = 0; idx < len; idx++) {\n        const p = idx % numPiles;\n        result[writePos[p]] = cards[idx];\n        writePos[p]--;\n    }\n    return makeShuffledDeck(result, [...deck.permutation, numPiles], scoreType);\n}\n\nfunction randomPileShuffle(deck, numPiles, scoreType) {\n    return shuffle(() => Math.floor(Math.random() * numPiles), deck, numPiles, scoreType);\n}\n\nconst SHUFFLE_FUNCTION_MAP = {\n    \"PILE\": pileShuffle,\n    \"RANDOM_PILE\": randomPileShuffle,\n};\n\n// --- Simulator ---\n// eslint-disable-next-line no-restricted-globals\nconst workerScope = self;\n\nworkerScope.onmessage = (e) => {\n    const { shuffleStrat, scoreType, maxShuffles, deckSize, minNumPiles, maxNumPiles } = e.data;\n    const pileDivisions = Array.from({ length: maxNumPiles - minNumPiles + 1 }, (_, i) => i + minNumPiles);\n    const shuffleFunction = SHUFFLE_FUNCTION_MAP[shuffleStrat];\n\n    const seen = new Set();\n    const baseCardList = Array.from({ length: deckSize }, (_, i) => i);\n    const baseDeck = makeShuffledDeck(baseCardList, [], scoreType);\n    seen.add(baseDeck.key);\n    let frontier = [baseDeck];\n    let best = null;\n\n    for (let round = 0; round < maxShuffles; round++) {\n        const roundTotal = frontier.length * pileDivisions.length;\n        const nextFrontier = [];\n\n        for (let j = 0; j < frontier.length; j++) {\n            const deck = frontier[j];\n            for (const numPiles of pileDivisions) {\n                const newDeck = shuffleFunction(deck, numPiles, scoreType);\n                if (!seen.has(newDeck.key)) {\n                    seen.add(newDeck.key);\n                    nextFrontier.push(newDeck);\n                    if (!best || newDeck.score > best.score) best = newDeck;\n                }\n            }\n            if (j % 50 === 0) {\n                workerScope.postMessage({\n                    type: 'progress',\n                    completed: (j + 1) * pileDivisions.length,\n                    total: roundTotal,\n                    round: round + 1,\n                });\n            }\n        }\n\n        // free old frontier keys from deck objects\n        for (const deck of frontier) { delete deck.key; }\n        frontier = nextFrontier;\n\n        workerScope.postMessage({\n            type: 'progress',\n            completed: roundTotal,\n            total: roundTotal,\n            round: round + 1,\n        });\n    }\n\n    workerScope.postMessage({\n        type: 'result',\n        data: best ? { permutation: best.permutation, score: best.score } : null,\n    });\n};\n"],"names":["SCORE_FUNCTION_MAP","cards","deckLen","length","counts","idx","diff","entropy","key","p","Math","abs","log","total","makeShuffledDeck","cardList","permutation","scoreType","score","join","SHUFFLE_FUNCTION_MAP","deck","numPiles","len","result","Array","full","floor","remainder","offset","pileStart","pileSize","writePos","pileSelector","piles","from","unshift","flat","shuffle","random","workerScope","self","onmessage","e","shuffleStrat","maxShuffles","deckSize","minNumPiles","maxNumPiles","data","pileDivisions","_","i","shuffleFunction","seen","Set","baseDeck","add","frontier","best","round","roundTotal","nextFrontier","j","newDeck","has","push","postMessage","type","completed"],"sourceRoot":""}