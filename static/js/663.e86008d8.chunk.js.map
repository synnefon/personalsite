{"version":3,"file":"static/js/663.e86008d8.chunk.js","mappings":"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","sources":["shufflenator/shuffleWorker.js"],"sourcesContent":["// Self-contained web worker for shuffle computation.\n// All logic is inlined to avoid import issues in worker context.\n\n// --- Scorers ---\n\nfunction calcAverageNeighborDist(cards) {\n    const deckLen = cards.length;\n    let total = 0;\n    for (let idx = 0; idx < deckLen; idx++) {\n        let diff = cards[(idx + 1) % deckLen] - cards[idx];\n        if (diff < 0) diff += deckLen;\n        total += diff;\n    }\n    return total / deckLen;\n}\n\nfunction calcLocationDelta(cards) {\n    let total = 0;\n    for (let idx = 0; idx < cards.length; idx++) {\n        total += Math.abs(idx - cards[idx]);\n    }\n    return total / cards.length;\n}\n\nlet entropyCounts = null;\nlet entropySlots = null;\nlet entropyLookup = null;\n\nfunction calcShannonEntropy(cards) {\n    const deckLen = cards.length;\n    if (!entropyCounts || entropyCounts.length < deckLen) {\n        entropyCounts = new Uint32Array(deckLen);\n        entropySlots = new Uint16Array(deckLen);\n        entropyLookup = new Float64Array(deckLen + 1);\n        for (let k = 1; k <= deckLen; k++) {\n            const p = k / deckLen;\n            entropyLookup[k] = -Math.log(p) * p;\n        }\n    }\n    let usedCount = 0;\n    for (let idx = 0; idx < deckLen - 1; idx++) {\n        let diff = cards[idx + 1] - cards[idx];\n        if (diff < 0) diff += deckLen;\n        if (entropyCounts[diff] === 0) entropySlots[usedCount++] = diff;\n        entropyCounts[diff]++;\n    }\n    let diff = cards[0] - cards[deckLen - 1];\n    if (diff < 0) diff += deckLen;\n    if (entropyCounts[diff] === 0) entropySlots[usedCount++] = diff;\n    entropyCounts[diff]++;\n\n    let entropy = 0;\n    for (let i = 0; i < usedCount; i++) {\n        const slot = entropySlots[i];\n        entropy += entropyLookup[entropyCounts[slot]];\n        entropyCounts[slot] = 0;\n    }\n    return entropy;\n}\n\nconst SCORE_FUNCTION_MAP = {\n    \"SHANNON_ENTROPY\": calcShannonEntropy,\n    \"NEIGHBOR_DIST\": calcAverageNeighborDist,\n    \"LOCATION_DELTA\": calcLocationDelta,\n};\n\n// --- Precomputed maps (populated per run) ---\nlet permMaps = {};\n\n// --- Shuffler ---\n\nfunction makeShuffledDeck(cardList, permutation, scoreType) {\n    return {\n        cardList,\n        permutation,\n        score: SCORE_FUNCTION_MAP[scoreType](cardList),\n    };\n}\n\nfunction shuffle(pileSelector, deck, numPiles, scoreType) {\n    const piles = Array.from({ length: numPiles }, () => []);\n    for (let idx = 0; idx < deck.cardList.length; idx++) {\n        piles[pileSelector(idx)].unshift(deck.cardList[idx]);\n    }\n    return makeShuffledDeck(piles.flat(), deck.permutation.concat(numPiles), scoreType);\n}\n\nfunction pileShuffle(deck, numPiles, scoreType) {\n    const cards = deck.cardList;\n    const len = cards.length;\n    const map = permMaps[numPiles];\n    const result = new Array(len);\n    for (let i = 0; i < len; i++) {\n        result[map[i]] = cards[i];\n    }\n    return makeShuffledDeck(result, deck.permutation.concat(numPiles), scoreType);\n}\n\nfunction randomPileShuffle(deck, numPiles, scoreType) {\n    return shuffle(() => Math.floor(Math.random() * numPiles), deck, numPiles, scoreType);\n}\n\nconst SHUFFLE_FUNCTION_MAP = {\n    \"PILE\": pileShuffle,\n    \"RANDOM_PILE\": randomPileShuffle,\n};\n\n// --- Simulator ---\n// eslint-disable-next-line no-restricted-globals\nconst workerScope = self;\n\nworkerScope.onmessage = (e) => {\n    const { shuffleStrat, scoreType, maxShuffles, deckSize, minNumPiles, maxNumPiles } = e.data;\n    const pileDivisions = Array.from({ length: maxNumPiles - minNumPiles + 1 }, (_, i) => i + minNumPiles);\n    const shuffleFunction = SHUFFLE_FUNCTION_MAP[shuffleStrat];\n    const numOptions = pileDivisions.length;\n\n    // Precompute permutation index maps for each pile count\n    permMaps = {};\n    for (const numPiles of pileDivisions) {\n        const map = new Int32Array(deckSize);\n        const full = Math.floor(deckSize / numPiles);\n        const remainder = deckSize % numPiles;\n        let offset = 0;\n        const pileStart = new Array(numPiles);\n        const pileSz = new Array(numPiles);\n        for (let p = 0; p < numPiles; p++) {\n            pileStart[p] = offset;\n            pileSz[p] = p < remainder ? full + 1 : full;\n            offset += pileSz[p];\n        }\n        const writePos = new Array(numPiles);\n        for (let p = 0; p < numPiles; p++) {\n            writePos[p] = pileStart[p] + pileSz[p] - 1;\n        }\n        for (let idx = 0; idx < deckSize; idx++) {\n            map[idx] = writePos[idx % numPiles];\n            writePos[idx % numPiles]--;\n        }\n        permMaps[numPiles] = map;\n    }\n\n    const baseCardList = Array.from({ length: deckSize }, (_, i) => i);\n    const baseDeck = makeShuffledDeck(baseCardList, [], scoreType);\n\n    let totalNodes = 0;\n    for (let d = 1; d <= maxShuffles; d++) totalNodes += Math.pow(numOptions, d);\n\n    let nodesVisited = 0;\n    let best = null;\n\n    // Iterative DFS â€” stack stays at O(maxShuffles * numOptions) entries max,\n    // vs BFS frontier which grows as O(numOptions^round).\n    const stack = [{ deck: baseDeck, depth: 0 }];\n\n    function processChunk() {\n        const start = performance.now();\n\n        while (stack.length > 0) {\n            const { deck, depth } = stack.pop();\n\n            if (depth > 0) {\n                nodesVisited++;\n                if (!best || deck.score > best.score) {\n                    best = { permutation: [...deck.permutation], score: deck.score };\n                }\n            }\n\n            if (depth < maxShuffles) {\n                for (let i = numOptions - 1; i >= 0; i--) {\n                    const child = shuffleFunction(deck, pileDivisions[i], scoreType);\n                    stack.push({ deck: child, depth: depth + 1 });\n                }\n            }\n\n            if (performance.now() - start > 200) {\n                workerScope.postMessage({\n                    type: 'progress',\n                    completed: nodesVisited,\n                    total: totalNodes,\n                    round: 1,\n                });\n                setTimeout(processChunk, 0);\n                return;\n            }\n        }\n\n        workerScope.postMessage({\n            type: 'result',\n            data: best ? { permutation: best.permutation, score: best.score } : null,\n        });\n    }\n\n    processChunk();\n};\n"],"names":["entropyCounts","entropySlots","entropyLookup","SCORE_FUNCTION_MAP","cards","deckLen","length","Uint32Array","Uint16Array","Float64Array","k","p","Math","log","usedCount","idx","diff","entropy","i","slot","total","abs","permMaps","makeShuffledDeck","cardList","permutation","scoreType","score","SHUFFLE_FUNCTION_MAP","deck","numPiles","len","map","result","Array","concat","pileSelector","piles","from","unshift","flat","shuffle","floor","random","workerScope","self","onmessage","e","shuffleStrat","maxShuffles","deckSize","minNumPiles","maxNumPiles","data","pileDivisions","_","shuffleFunction","numOptions","Int32Array","full","remainder","offset","pileStart","pileSz","writePos","baseDeck","totalNodes","d","pow","nodesVisited","best","stack","depth","processChunk","start","performance","now","pop","child","push","postMessage","type","completed","round","setTimeout"],"sourceRoot":""}