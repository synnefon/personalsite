{"version":3,"file":"static/js/610.8e94c2a6.chunk.js","mappings":"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","sources":["game_of_life/constants.ts","game_of_life/Cell.tsx","game_of_life/patterns.ts","game_of_life/utils.ts","game_of_life/useGameLogic.ts","game_of_life/GameOfLife.tsx","game_of_life/useInteractions.ts"],"sourcesContent":["// General-purpose constants (no magic numbers)\nexport const DEFAULT_TICK_PER_SEC = 4;\nexport const MAX_TICK_PER_SEC = 15;\nexport const CELL_SIZE = 20; // px - fixed cell size\nexport const MIN_ZOOM = 0.3;\nexport const MAX_ZOOM = 4;\nexport const DRAG_THRESHOLD_PX = 5;\n\n// Memory management constants\nexport const MAX_LIVE_CELLS = 50000; // Maximum cells before pausing simulation\nexport const CULLING_MARGIN = 100; // Cells beyond viewport to keep\n\n// Key encoding constants - using offset encoding to handle negative coordinates\n// JavaScript numbers have 53 bits of integer precision, so we can safely use:\n// - 26 bits for x (range: -33M to +33M)\n// - 26 bits for y (range: -33M to +33M)\nexport const COORD_OFFSET = 33554432; // 2^25 - offset to ensure coordinates are always positive\nexport const KEY_MULTIPLIER = 67108864; // 2^26 - multiplier for x coordinate\n\n// Game of Life rules\nexport const LIFE_NEIGHBORS_BIRTH = 3;\n\n// Gold: #d9a60e\nexport const COLOR_GOLD = { r: 217, g: 166, b: 14 };\n\nexport const WHEEL_ZOOM_DELTA = 0.1;\nexport const PINCH_ZOOM_DAMPING = 0.5;\nexport const ZOOM_DEFAULT_LEVEL = 1;\nexport const EXTRA_ROWS = 1; // for rendering extra padding\n","import React, { memo } from \"react\";\nimport { COLOR_GOLD } from \"./constants.ts\";\n\n// Memoized cell component - only re-renders when filled state changes\nexport const Cell = memo(\n  ({ x, y, filled }: { x: number; y: number; filled: boolean }) => (\n    <div\n      data-cell-x={x}\n      data-cell-y={y}\n      className={`gol-board-cell${filled ? \" filled\" : \"\"}`}\n      style={\n        filled\n          ? {\n              backgroundColor: `rgb(${COLOR_GOLD.r}, ${COLOR_GOLD.g}, ${COLOR_GOLD.b})`,\n            }\n          : undefined\n      }\n    />\n  )\n);\nCell.displayName = \"Cell\";\n","/**\n * Conway's Game of Life - Starting Patterns\n *\n * Patterns are defined in ASCII art format for readability:\n * - '*' = live cell\n * - '.' or ' ' = dead cell\n *\n * Patterns are defined starting from (0, 0). The game will auto-center them.\n */\n\nexport type Pattern = [number, number][];\n\nexport interface PatternConfig {\n  name: string;\n  pattern: Pattern;\n}\n\n/**\n * Parse ASCII art pattern into coordinate array\n * @param art - ASCII art string where '*' = live, '.' = dead\n */\nfunction parsePattern(art: string): Pattern {\n  const lines = art.trim().split(\"\\n\");\n  const coords: Pattern = [];\n\n  // Parse each cell\n  lines.forEach((line, y) => {\n    for (let x = 0; x < line.length; x++) {\n      const char = line[x];\n      if (char === \"*\") {\n        coords.push([x, y]);\n      }\n    }\n  });\n\n  return coords;\n}\n\nconst TABLE: Pattern = parsePattern(`\n****\n*..*\n`);\n\nconst HOLLOW_SQUARES: Pattern = parsePattern(`\n***.***\n*.*.*.*\n***.***\n`);\n\nconst GLIDER_GUN: Pattern = parsePattern(`\n........................*...........\n......................*.*..........*\n............**......**............**\n...........*...*....**..............*\n**........*.....*...**..............*\n**........*...*.**....*.*..........*\n..........*.....*.......*...........\n...........*...*....................\n............**......................\n`);\n\nconst ONE_TWO_THREE: Pattern = parsePattern(`\n..**......\n*..*......\n**.*.**...\n.*.*..*...\n.*....*.**\n..***.*.**\n.....*....\n....*.....\n....**....\n`);\n\n// Evolves for 5,206 generations before stabilizing\nconst ACORN: Pattern = parsePattern(`\n.*.....\n...*...\n**..***.\n`);\n\n// Evolves for 1,103 generations\nconst R_PENTOMINO: Pattern = parsePattern(`\n.**\n**.\n.*.\n`);\n\n// Lightweight Spaceship - travels horizontally\nconst LWSS: Pattern = parsePattern(`\n*..*\n....*\n*...*\n.****\n`);\n\n// Period-15 oscillator\nconst PENTADECATHLON: Pattern = parsePattern(`\n.*.\n.*.\n*.*\n.*.\n.*.\n.*.\n.*.\n*.*\n.*.\n.*.\n`);\n\n// Methuselah - 17,331 generations before stabilizing\nconst RABBITS: Pattern = parsePattern(`\n..*....*\n**......\n.**.***.\n`);\n\n\n/**\n * All available starting patterns\n * Add new patterns here to include them in random selection\n */\nexport const PATTERNS: PatternConfig[] = [\n  {\n    name: \"hollow squares\",\n    pattern: HOLLOW_SQUARES,\n  },\n  {\n    name: \"gosper glider gun\",\n    pattern: GLIDER_GUN,\n  },\n  {\n    name: \"acorn\",\n    pattern: ACORN,\n  },\n  {\n    name: \"r-pentomino\",\n    pattern: R_PENTOMINO,\n  },\n  {\n    name: \"lightweight spaceship\",\n    pattern: LWSS,\n  },\n  {\n    name: \"pentadecathlon\",\n    pattern: PENTADECATHLON,\n  },\n  {\n    name: \"rabbits\",\n    pattern: RABBITS,\n  },\n  {\n    name: \"one two three\",\n    pattern: ONE_TWO_THREE,\n  },\n    {\n      name: \"table\",\n      pattern: TABLE,\n    },\n];\n\n/**\n * Select a random pattern from the available patterns\n */\nexport function getRandomPattern(): PatternConfig {\n  const randomIndex = Math.floor(Math.random() * PATTERNS.length);\n  const pattern = PATTERNS[randomIndex];\n  console.log(`Starting pattern: ${pattern.name}`);\n  return pattern;\n}\n","import { COORD_OFFSET, KEY_MULTIPLIER } from \"./constants.ts\";\n\n// helpers for Set keys - using offset encoding to correctly handle negative coordinates\nexport const makeKey = (x: number, y: number): number =>\n  (x + COORD_OFFSET) * KEY_MULTIPLIER + (y + COORD_OFFSET);\n\nexport const parseKey = (k: number): [number, number] => {\n  const x = Math.floor(k / KEY_MULTIPLIER) - COORD_OFFSET;\n  const y = (k % KEY_MULTIPLIER) - COORD_OFFSET;\n  return [x, y];\n};\n","import { useCallback, useEffect, useRef } from \"react\";\nimport {\n  MAX_LIVE_CELLS,\n  CULLING_MARGIN,\n  LIFE_NEIGHBORS_BIRTH,\n} from \"./constants.ts\";\nimport { makeKey, parseKey } from \"./utils.ts\";\nimport { type Viewport } from \"./types.ts\";\n\ninterface UseGameLogicProps {\n  liveCellsRef: React.MutableRefObject<Set<number>>;\n  viewportRef: React.MutableRefObject<Viewport>;\n  ticksPerSec: React.MutableRefObject<number>;\n  setGeneration: React.Dispatch<React.SetStateAction<number>>;\n  setTickCount: React.Dispatch<React.SetStateAction<number>>;\n  setRunning: React.Dispatch<React.SetStateAction<boolean>>;\n}\n\nfunction checkCellLimit(currentSize: number, runningRef: React.MutableRefObject<boolean>, animationFrameRef: React.MutableRefObject<number | null>, setGeneration: React.Dispatch<React.SetStateAction<number>>): boolean {\n  if (currentSize < MAX_LIVE_CELLS) return false;\n  runningRef.current = false;\n  animationFrameRef.current = null;\n  alert(\n    `Simulation paused: cell limit reached (${MAX_LIVE_CELLS} cells).`\n  );\n  setGeneration((g) => g + 1);\n  return true;\n}\n\nfunction computeViewportBounds(currentViewport: Viewport) {\n  const minX = Math.floor(currentViewport.offset.x) - CULLING_MARGIN;\n  const maxX = Math.floor(currentViewport.offset.x) + currentViewport.dimensions.cols + CULLING_MARGIN;\n  const minY = Math.floor(currentViewport.offset.y) - CULLING_MARGIN;\n  const maxY = Math.floor(currentViewport.offset.y) + currentViewport.dimensions.rows + CULLING_MARGIN;\n  return { minX, maxX, minY, maxY };\n}\n\nfunction countNeighbours(liveCells: Set<number>) {\n  const neighbourCounter = new Map<number, number>();\n  liveCells.forEach((cellKey) => {\n    const [x, y] = parseKey(cellKey);\n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        if (dx === 0 && dy === 0) continue;\n        const neighKey = makeKey(x + dx, y + dy);\n        neighbourCounter.set(\n          neighKey,\n          (neighbourCounter.get(neighKey) || 0) + 1\n        );\n      }\n    }\n  });\n  return neighbourCounter;\n}\n\nfunction applyRules(\n  neighbourCounter: Map<number, number>,\n  liveCells: Set<number>,\n  { minX, maxX, minY, maxY }: { minX: number; maxX: number; minY: number; maxY: number; }\n) {\n  const nextGen = new Set<number>();\n  neighbourCounter.forEach((count, cellKey) => {\n    const alive = liveCells.has(cellKey);\n    if (\n      count === LIFE_NEIGHBORS_BIRTH ||\n      (alive && (count === 2 || count === 3))\n    ) {\n      const [x, y] = parseKey(cellKey);\n      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {\n        nextGen.add(cellKey);\n      }\n    }\n  });\n  return nextGen;\n}\n\nfunction growthDetection(nextGenSize: number, currentSize: number, growthCountRef: React.MutableRefObject<number>) {\n  if (nextGenSize > currentSize * 1.5) {\n    growthCountRef.current++;\n    if (growthCountRef.current >= 10) {\n      console.warn(\n        `Exponential growth detected: ${currentSize} → ${nextGenSize} cells over 10 generations`\n      );\n      growthCountRef.current = 0;\n    }\n  } else {\n    growthCountRef.current = 0;\n  }\n}\n\nexport function useGameLogic({\n  liveCellsRef,\n  viewportRef,\n  ticksPerSec,\n  setGeneration,\n  setTickCount,\n  setRunning,\n}: UseGameLogicProps) {\n  const runningRef = useRef<boolean>(false);\n  const animationFrameRef = useRef<number | null>(null);\n  const lastTickTimeRef = useRef<number>(0);\n  const growthCountRef = useRef<number>(0);\n\n  const runTick = useCallback(\n    (timestamp: number = performance.now()) => {\n      if (!runningRef.current) {\n        animationFrameRef.current = null;\n        return;\n      }\n\n      const elapsed = timestamp - lastTickTimeRef.current;\n      const interval = 1_000 / ticksPerSec.current;\n\n      if (elapsed < interval) {\n        animationFrameRef.current = requestAnimationFrame(runTick);\n        return;\n      }\n\n      const currentSize = liveCellsRef.current.size;\n      if (checkCellLimit(currentSize, runningRef, animationFrameRef, setGeneration)) {\n        return;\n      }\n\n      const currentViewport = viewportRef.current;\n      const bounds = computeViewportBounds(currentViewport);\n\n      const neighbourCounter = countNeighbours(liveCellsRef.current);\n\n      const nextGen = applyRules(neighbourCounter, liveCellsRef.current, bounds);\n\n      if (nextGen.size === 0) {\n        runningRef.current = false;\n        setRunning(false);\n        animationFrameRef.current = null;\n        liveCellsRef.current = nextGen;\n        setGeneration((g) => g + 1);\n        return;\n      }\n\n      growthDetection(nextGen.size, currentSize, growthCountRef);\n\n      liveCellsRef.current = nextGen;\n      setGeneration((g) => g + 1);\n      setTickCount((t) => t + 1);\n      lastTickTimeRef.current = timestamp;\n\n      animationFrameRef.current = requestAnimationFrame(runTick);\n    },\n    [liveCellsRef, viewportRef, ticksPerSec, setGeneration, setTickCount, setRunning]\n  );\n\n  // Cleanup animation frame on unmount\n  useEffect(() => {\n    return () => {\n      if (animationFrameRef.current !== null) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    runningRef,\n    animationFrameRef,\n    lastTickTimeRef,\n    runTick,\n  };\n}\n","import React, {\n  ReactElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type CSSProperties,\n} from \"react\";\nimport { Cell } from \"./Cell.tsx\";\nimport * as CONSTANTS from \"./constants.ts\";\nimport * as patterns from \"./patterns.ts\";\nimport type { Viewport } from \"./types.ts\";\nimport { useGameLogic } from \"./useGameLogic.ts\";\nimport { useInteractions } from \"./useInteractions.ts\";\nimport { makeKey } from \"./utils.ts\";\n\nimport \"../styles/gameoflife.css\";\n\n/*\n  Infinite Game of Life with a square viewport size selector.\n  – A single \"size\" input controls both rows and columns (rows = cols).\n  – Live cells stored sparsely in a Set keyed by \"x,y\".\n  – Arrow keys pan; click toggles cells; start/pause runs generations every 250 ms.\n  – Sidebar elements are neatly stacked, with the rules in an ordered list so\n    they never overlap the start/pause button.\n*/\n\nexport default function GameOfLifeInfinite(): ReactElement {\n  /* --------------------------------------------------------------------- */\n  /*  State                                                                */\n  /* --------------------------------------------------------------------- */\n  const ticksPerSec = useRef<number>(CONSTANTS.DEFAULT_TICK_PER_SEC);\n\n  // Calculate grid dimensions based on window size and zoom\n  const initialRows = Math.ceil(\n    window.innerHeight / (CONSTANTS.CELL_SIZE * CONSTANTS.ZOOM_DEFAULT_LEVEL)\n  );\n  const initialCols = Math.ceil(\n    window.innerWidth / (CONSTANTS.CELL_SIZE * CONSTANTS.ZOOM_DEFAULT_LEVEL)\n  );\n\n  /* ------------------------------------------------------------------ */\n  /*  Starting pattern                                                  */\n  /* ------------------------------------------------------------------ */\n  const [{ initialLive, patternCenterX, patternCenterY, selectedPattern }] =\n    useState(() => {\n      const pattern = patterns.getRandomPattern();\n      const live = new Set<number>(\n        pattern.pattern.map(([x, y]) => makeKey(x, y))\n      );\n\n      // Calculate pattern bounds to center it in viewport\n      const patternBounds = {\n        minX: Math.min(...pattern.pattern.map(([x]) => x)),\n        maxX: Math.max(...pattern.pattern.map(([x]) => x)),\n        minY: Math.min(...pattern.pattern.map(([, y]) => y)),\n        maxY: Math.max(...pattern.pattern.map(([, y]) => y)),\n      };\n      const centerX = (patternBounds.minX + patternBounds.maxX) / 2;\n      const centerY = (patternBounds.minY + patternBounds.maxY) / 2;\n\n      return {\n        selectedPattern: pattern,\n        initialLive: live,\n        patternCenterX: centerX,\n        patternCenterY: centerY,\n      };\n    });\n\n  // Batched viewport state to prevent race conditions during zoom/pan\n  const [viewport, setViewport] = useState<Viewport>({\n    zoom: CONSTANTS.ZOOM_DEFAULT_LEVEL,\n    offset: {\n      x: patternCenterX - initialCols / 2,\n      y: patternCenterY - initialRows / 2,\n    },\n    dimensions: { rows: initialRows, cols: initialCols },\n  });\n\n  // Keep ref in sync for runTick to access without triggering re-renders\n  const viewportRef = useRef(viewport);\n  useEffect(() => {\n    viewportRef.current = viewport;\n  }, [viewport]);\n\n  const { zoom, offset, dimensions } = viewport;\n  const viewRows = dimensions.rows;\n  const viewCols = dimensions.cols;\n\n  // Handle window resize\n  useEffect(() => {\n    const handleResize = (): void => {\n      const currentViewport = viewportRef.current;\n      setViewport({\n        ...currentViewport,\n        dimensions: {\n          rows: Math.ceil(\n            window.innerHeight / (CONSTANTS.CELL_SIZE * currentViewport.zoom)\n          ),\n          cols: Math.ceil(\n            window.innerWidth / (CONSTANTS.CELL_SIZE * currentViewport.zoom)\n          ),\n        },\n      });\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  // Generation counter for triggering re-renders when cells change\n  const [generation, setGeneration] = useState<number>(0);\n\n  // Tick counter for display\n  const [tickCount, setTickCount] = useState<number>(0);\n  const tickCountRef = useRef<number>(0);\n\n  // Keep tickCountRef in sync with tickCount\n  useEffect(() => {\n    tickCountRef.current = tickCount;\n  }, [tickCount]);\n\n  // Splash screen state\n  const [showSplash, setShowSplash] = useState<boolean>(true);\n  const [fadingSplash, setFadingSplash] = useState<boolean>(false);\n\n  // Reset button animation state\n  const [resetClicked, setResetClicked] = useState<boolean>(false);\n\n  // Pattern selection state\n  const [currentPattern, setCurrentPattern] =\n    useState<patterns.PatternConfig | null>(selectedPattern);\n\n  // Reset state - stores the cell state to reset to (make a copy of initialLive)\n  const resetStateRef = useRef<Set<number>>(new Set(initialLive));\n  const resetOffsetRef = useRef<{ x: number; y: number }>({\n    x: patternCenterX - initialCols / 2,\n    y: patternCenterY - initialRows / 2,\n  });\n  const resetTickCountRef = useRef<number>(0);\n\n  // Fullscreen state\n  const [isFullscreen, setIsFullscreen] = useState<boolean>(false);\n\n  // Info popup state\n  const [showInfo, setShowInfo] = useState<boolean>(false);\n  const wasRunningBeforeInfoRef = useRef<boolean>(false);\n\n  // Handle fullscreen changes\n  useEffect(() => {\n    const handleFullscreenChange = (): void => {\n      setIsFullscreen(!!document.fullscreenElement);\n    };\n\n    document.addEventListener(\"fullscreenchange\", handleFullscreenChange);\n    return () =>\n      document.removeEventListener(\"fullscreenchange\", handleFullscreenChange);\n  }, []);\n\n  // Handle escape key to close info popup (prevent exiting fullscreen)\n  useEffect(() => {\n    const handleEscapeKey = (e: KeyboardEvent): void => {\n      if (e.key === \"Escape\" && showInfo) {\n        e.preventDefault();\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n        setShowInfo(false);\n      }\n    };\n\n    if (showInfo) {\n      document.addEventListener(\"keydown\", handleEscapeKey, { capture: true });\n      return () => document.removeEventListener(\"keydown\", handleEscapeKey, { capture: true });\n    }\n  }, [showInfo]);\n\n  const toggleFullscreen = useCallback((): void => {\n    if (!document.fullscreenElement) {\n      document.documentElement.requestFullscreen().catch((err) => {\n        console.error(\"Error attempting to enable fullscreen:\", err);\n      });\n    } else {\n      document.exitFullscreen();\n    }\n  }, []);\n\n  // Handle splash screen timing\n  useEffect(() => {\n    // Start fade out after 2 seconds\n    const fadeTimer = setTimeout(() => {\n      setFadingSplash(true);\n    }, 2000);\n\n    // Remove splash completely after 3 seconds (2s display + 1s fade)\n    const removeTimer = setTimeout(() => {\n      setShowSplash(false);\n    }, 3000);\n\n    return () => {\n      clearTimeout(fadeTimer);\n      clearTimeout(removeTimer);\n    };\n  }, []);\n\n  /* ------------------------------------------------------------------ */\n  /*  State                                                             */\n  /* ------------------------------------------------------------------ */\n  const liveCellsRef = useRef<Set<number>>(initialLive);\n  const [running, setRunning] = useState<boolean>(false);\n\n  /* --------------------------------------------------------------------- */\n  /*  Core Life Logic                                                      */\n  /* --------------------------------------------------------------------- */\n  const { runningRef, animationFrameRef, lastTickTimeRef, runTick } =\n    useGameLogic({\n      liveCellsRef,\n      viewportRef,\n      ticksPerSec,\n      setGeneration,\n      setTickCount,\n      setRunning,\n    });\n\n  /* --------------------------------------------------------------------- */\n  /*  Interaction Helpers                                                  */\n  /* --------------------------------------------------------------------- */\n  const toggleCell = useCallback((x: number, y: number): void => {\n    if (isDraggingRef.current) return;\n\n    const k = makeKey(x, y);\n    const set = liveCellsRef.current;\n    set.has(k) ? set.delete(k) : set.add(k);\n\n    setGeneration((g) => g + 1);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const loadPattern = useCallback(\n    (pattern: patterns.PatternConfig | null): void => {\n      // Pause the simulation\n      runningRef.current = false;\n      setRunning(false);\n      if (animationFrameRef.current !== null) {\n        cancelAnimationFrame(animationFrameRef.current);\n        animationFrameRef.current = null;\n      }\n\n      // Reset tick counter\n      setTickCount(0);\n\n      // Load the pattern (or empty if null)\n      const newLive = pattern\n        ? new Set<number>(pattern.pattern.map(([x, y]) => makeKey(x, y)))\n        : new Set<number>();\n\n      // Update cells\n      liveCellsRef.current = newLive;\n\n      // Calculate center and update viewport\n      const currentViewport = viewportRef.current;\n      let newOffset = currentViewport.offset;\n\n      if (pattern) {\n        const patternBounds = {\n          minX: Math.min(...pattern.pattern.map(([x]) => x)),\n          maxX: Math.max(...pattern.pattern.map(([x]) => x)),\n          minY: Math.min(...pattern.pattern.map(([, y]) => y)),\n          maxY: Math.max(...pattern.pattern.map(([, y]) => y)),\n        };\n        const centerX = (patternBounds.minX + patternBounds.maxX) / 2;\n        const centerY = (patternBounds.minY + patternBounds.maxY) / 2;\n\n        newOffset = {\n          x: centerX - currentViewport.dimensions.cols / 2,\n          y: centerY - currentViewport.dimensions.rows / 2,\n        };\n\n        setViewport({\n          ...currentViewport,\n          offset: newOffset,\n        });\n      }\n\n      // Save as reset state\n      resetStateRef.current = new Set(newLive);\n      resetOffsetRef.current = newOffset;\n      resetTickCountRef.current = 0;\n\n      setGeneration((g) => g + 1);\n    },\n    [runningRef, animationFrameRef, viewportRef]\n  );\n\n  const resetBoard = useCallback((): void => {\n    // Pause the simulation\n    runningRef.current = false;\n    setRunning(false);\n    if (animationFrameRef.current !== null) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n\n    // Reset tick counter to saved value\n    setTickCount(resetTickCountRef.current);\n\n    // Load from saved reset state\n    liveCellsRef.current = new Set(resetStateRef.current);\n\n    // Restore saved viewport offset\n    const currentViewport = viewportRef.current;\n    setViewport({\n      ...currentViewport,\n      offset: resetOffsetRef.current,\n    });\n\n    setGeneration((g) => g + 1);\n\n    // Trigger animation\n    setResetClicked(true);\n    setTimeout(() => {\n      setResetClicked(false);\n    }, 900);\n  }, [runningRef, animationFrameRef, viewportRef]);\n\n  const onToggleStart = useCallback((): void => {\n    const newRunning = !runningRef.current;\n    runningRef.current = newRunning;\n    setRunning(newRunning); // Update state immediately for UI\n\n    if (newRunning) {\n      // Save current state as reset state when starting\n      resetStateRef.current = new Set(liveCellsRef.current);\n      resetOffsetRef.current = viewportRef.current.offset;\n      resetTickCountRef.current = tickCountRef.current;\n\n      lastTickTimeRef.current = performance.now();\n      runTick();\n    } else {\n      if (animationFrameRef.current !== null) {\n        cancelAnimationFrame(animationFrameRef.current);\n        animationFrameRef.current = null;\n      }\n      setGeneration((g) => g + 1);\n    }\n  }, [\n    runTick,\n    runningRef,\n    animationFrameRef,\n    lastTickTimeRef,\n    viewportRef,\n    tickCountRef,\n  ]);\n\n  /* --------------------------------------------------------------------- */\n  /*  Interaction Handlers                                                 */\n  /* --------------------------------------------------------------------- */\n  const { isDraggingRef, isDragging, isPointerDown } = useInteractions({\n    viewportRef,\n    setViewport,\n    onToggleStart,\n    toggleFullscreen,\n  });\n\n  /* --------------------------------------------------------------------- */\n  /*  Info Popup Pause/Resume Logic                                        */\n  /* --------------------------------------------------------------------- */\n  // Pause game when info popup opens, resume if it was running\n  useEffect(() => {\n    if (showInfo) {\n      // Opening popup - save running state and pause\n      wasRunningBeforeInfoRef.current = runningRef.current;\n      if (runningRef.current) {\n        runningRef.current = false;\n        setRunning(false);\n        if (animationFrameRef.current !== null) {\n          cancelAnimationFrame(animationFrameRef.current);\n          animationFrameRef.current = null;\n        }\n      }\n    } else if (wasRunningBeforeInfoRef.current) {\n      // Closing popup - resume if it was running before\n      runningRef.current = true;\n      setRunning(true);\n      lastTickTimeRef.current = performance.now();\n      runTick();\n    }\n  }, [showInfo, runningRef, animationFrameRef, lastTickTimeRef, runTick]);\n\n  /* --------------------------------------------------------------------- */\n  /*  Render Board                                                         */\n  /* --------------------------------------------------------------------- */\n  const offsetX = Math.floor(offset.x);\n  const offsetY = Math.floor(offset.y);\n\n  const fractionalX = offset.x - offsetX;\n  const fractionalY = offset.y - offsetY;\n\n  // Event delegation handler for cell clicks\n  const handleBoardClick = useCallback(\n    (e: React.MouseEvent<HTMLDivElement>) => {\n      const target = e.target as HTMLElement;\n      if (!target.classList.contains(\"gol-board-cell\")) return;\n\n      const x = target.getAttribute(\"data-cell-x\");\n      const y = target.getAttribute(\"data-cell-y\");\n      if (x && y) {\n        toggleCell(Number(x), Number(y));\n      }\n    },\n    [toggleCell]\n  );\n\n  // Memoized grid rendering - only recalculates when dependencies change\n  // generation is needed to trigger re-render when cells change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const rows = useMemo(() => {\n    const result: ReactElement[] = [];\n    for (let r = 0; r < viewRows + CONSTANTS.EXTRA_ROWS; r++) {\n      const cells: ReactElement[] = [];\n      for (let c = 0; c < viewCols + CONSTANTS.EXTRA_ROWS; c++) {\n        const cellX = c + offsetX;\n        const cellY = r + offsetY;\n        const filled = liveCellsRef.current.has(makeKey(cellX, cellY));\n\n        cells.push(\n          <Cell\n            key={`cell-${cellX},${cellY}`}\n            x={cellX}\n            y={cellY}\n            filled={filled}\n          />\n        );\n      }\n      result.push(\n        <div key={`row-${r + offsetY}`} className=\"gol-board-row\">\n          {cells}\n        </div>\n      );\n    }\n    return result;\n    // eslint-disable-next-line\n  }, [offsetX, offsetY, viewRows, viewCols, generation]);\n\n  /* --------------------------------------------------------------------- */\n  /*  Helpers                                                              */\n  /* --------------------------------------------------------------------- */\n  const displayVal = (v: number): string | number => (v === 0 ? \"\" : v);\n\n  return (\n    <div id=\"game-of-life\" className=\"gol-container\">\n      {/* SPLASH SCREEN */}\n      {showSplash && (\n        <div className={`gol-splash${fadingSplash ? \" fading\" : \"\"}`}>\n          <div className=\"gol-splash-text\">\n            conway's\n            <br />\n            game of life\n          </div>\n        </div>\n      )}\n\n      {/* BOARD */}\n      <div\n        className={`gol-board${\n          isPointerDown && !isDragging ? \" mouse-down\" : \"\"\n        }${isDragging ? \" dragging\" : \"\"}${running ? \" running\" : \"\"}${\n          zoom >= 2 ? \" zoomed-in\" : \"\"\n        }`}\n        style={\n          {\n            \"--rows\": viewRows,\n            \"--cols\": viewCols,\n            \"--zoom\": zoom,\n          } as CSSProperties\n        }\n      >\n        <div\n          className=\"gol-board-content\"\n          onClick={handleBoardClick}\n          style={{\n            transform: `translate(${-fractionalX * (100 / viewCols)}%, ${\n              -fractionalY * (100 / viewRows)\n            }%)`,\n          }}\n        >\n          {rows}\n        </div>\n      </div>\n\n      {/* CONTROLS */}\n      <aside className=\"gol-controls\">\n        {/* pattern selector */}\n        <div className=\"gol-control-group\">\n          <label>\n            <div>pattern</div>\n            <select\n              className=\"gol-pattern-select\"\n              value={currentPattern?.name ?? \"empty\"}\n              onChange={(e) => {\n                const value = e.target.value;\n                if (value === \"empty\") {\n                  setCurrentPattern(null);\n                  loadPattern(null);\n                } else {\n                  const pattern = patterns.PATTERNS.find(\n                    (p) => p.name === value\n                  );\n                  if (pattern) {\n                    setCurrentPattern(pattern);\n                    loadPattern(pattern);\n                  }\n                }\n              }}\n            >\n              <option value=\"empty\">empty</option>\n              {patterns.PATTERNS.map((pattern) => (\n                <option key={pattern.name} value={pattern.name}>\n                  {pattern.name}\n                </option>\n              ))}\n            </select>\n          </label>\n        </div>\n\n        {/* start / pause */}\n        <div\n          className={`gol-start-button${running ? \" running\" : \"\"}`}\n          onClick={onToggleStart}\n        >\n          {running ? \"⏸\" : \"▶\"}\n        </div>\n        <div\n          className={`gol-start-button${resetClicked ? \" clearing\" : \"\"}`}\n          onClick={resetBoard}\n        >\n          ⟲\n        </div>\n\n        {/* speed selector */}\n        <div className=\"gol-control-group\">\n          <label>\n            <div>ticks / second</div>\n            <input\n              type=\"number\"\n              min={1}\n              max={CONSTANTS.MAX_TICK_PER_SEC}\n              step={1}\n              value={displayVal(ticksPerSec.current)}\n              onChange={(e) => {\n                const raw = e.target.value;\n                if (raw === \"\") {\n                  ticksPerSec.current = 0;\n                } else {\n                  const n = Math.max(\n                    0,\n                    Math.min(CONSTANTS.MAX_TICK_PER_SEC, Number(raw))\n                  );\n                  ticksPerSec.current = n;\n                }\n                setGeneration((g) => g + 1);\n              }}\n            />\n          </label>\n        </div>\n\n        {/* reset button */}\n      </aside>\n\n      {/* INFO BUTTON */}\n      <div\n        className=\"gol-info-button\"\n        onClick={() => setShowInfo(true)}\n        title=\"Rules\"\n      >\n        ⚙\n      </div>\n\n      {/* INFO POPUP */}\n      {showInfo && (\n        <div className=\"gol-info-overlay\" onClick={() => setShowInfo(false)}>\n          <div className=\"gol-info-popup\" onClick={(e) => e.stopPropagation()}>\n            <button\n              className=\"gol-info-close\"\n              onClick={() => setShowInfo(false)}\n              title=\"Close (Esc)\"\n            >\n              ✕\n            </button>\n            <h2>conway's game of life</h2>\n            <div className=\"gol-info-content\">\n              <p>\n                a cellular automaton in which cells live, die, or reproduce\n                based on simple rules:\n              </p>\n              <ol>\n                <li>\n                  <strong>underpopulation:</strong> a live cell with fewer than\n                  2 live neighbors dies\n                </li>\n                <li>\n                  <strong>survival:</strong> a live cell with 2 or 3 live\n                  neighbors survives\n                </li>\n                <li>\n                  <strong>reproduction:</strong> a dead cell with exactly 3 live\n                  neighbors becomes alive\n                </li>\n                <li>\n                  <strong>overpopulation:</strong> a live cell with more than 3\n                  live neighbors dies\n                </li>\n              </ol>\n              <p className=\"gol-info-controls\">\n                <strong>controls:</strong>\n                <br />\n                click cells to toggle • arrow keys to pan • scroll to zoom •\n                drag to pan • f for fullscreen\n              </p>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* TICK COUNTER */}\n      <div className=\"gol-tick-counter\">{tickCount}</div>\n\n      {/* FULLSCREEN BUTTON */}\n      <div\n        className=\"gol-fullscreen-button\"\n        onClick={toggleFullscreen}\n        title={isFullscreen ? \"Exit fullscreen (F)\" : \"Fullscreen (F)\"}\n      >\n        <div\n          style={{\n            display: \"flex\",\n            flexDirection: \"column\",\n            lineHeight: `${isFullscreen ? 1 : 0.3}`,\n            fontSize: \"2.4rem\",\n          }}\n        >\n          <div>{isFullscreen ? \"⌟⌞\" : \"⌜⌝\"}</div>\n          <div>{isFullscreen ? \"⌝⌜\" : \"⌞⌟\"}</div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport {\n  DRAG_THRESHOLD_PX,\n  MIN_ZOOM,\n  MAX_ZOOM,\n  CELL_SIZE,\n  WHEEL_ZOOM_DELTA,\n  PINCH_ZOOM_DAMPING,\n} from \"./constants.ts\";\nimport { type Viewport } from \"./types.ts\";\n\ninterface UseInteractionsProps {\n  viewportRef: React.MutableRefObject<Viewport>;\n  setViewport: React.Dispatch<React.SetStateAction<Viewport>>;\n  onToggleStart: () => void;\n  toggleFullscreen: () => void;\n}\n\nexport function useInteractions({\n  viewportRef,\n  setViewport,\n  onToggleStart,\n  toggleFullscreen,\n}: UseInteractionsProps) {\n  const isDraggingRef = useRef(false);\n  const [isDragging, setIsDragging] = useState(false);\n  const [isPointerDown, setIsPointerDown] = useState(false);\n\n  // arrow-key panning and Enter/Space for play/pause\n  useEffect(() => {\n    const KEY_MOVE_AMOUNT = 1;\n    const handler = (e: KeyboardEvent): void => {\n      switch (e.key) {\n        case \"ArrowDown\":\n          setViewport((v) => ({\n            ...v,\n            offset: { ...v.offset, y: v.offset.y - KEY_MOVE_AMOUNT },\n          }));\n          break;\n        case \"ArrowUp\":\n          setViewport((v) => ({\n            ...v,\n            offset: { ...v.offset, y: v.offset.y + KEY_MOVE_AMOUNT },\n          }));\n          break;\n        case \"ArrowRight\":\n          setViewport((v) => ({\n            ...v,\n            offset: { ...v.offset, x: v.offset.x - KEY_MOVE_AMOUNT },\n          }));\n          break;\n        case \"ArrowLeft\":\n          setViewport((v) => ({\n            ...v,\n            offset: { ...v.offset, x: v.offset.x + KEY_MOVE_AMOUNT },\n          }));\n          break;\n        case \"Enter\":\n        case \" \":\n          e.preventDefault();\n          onToggleStart();\n          break;\n        case \"f\":\n        case \"F\":\n          e.preventDefault();\n          toggleFullscreen();\n          break;\n      }\n    };\n    window.addEventListener(\"keydown\", handler);\n    return () => window.removeEventListener(\"keydown\", handler);\n  }, [onToggleStart, toggleFullscreen, setViewport]);\n\n  // wheel zoom\n  useEffect(() => {\n    const handler = (e: WheelEvent): void => {\n      e.preventDefault();\n      const board = e.currentTarget as HTMLElement;\n      const rect = board.getBoundingClientRect();\n\n      // Mouse position relative to board (0 to 1)\n      const mouseXRatio = (e.clientX - rect.left) / rect.width;\n      const mouseYRatio = (e.clientY - rect.top) / rect.height;\n\n      const currentViewport = viewportRef.current;\n\n      // Adjust zoom (scroll down = zoom in, scroll up = zoom out)\n      const zoomDelta = e.deltaY > 0 ? WHEEL_ZOOM_DELTA : -WHEEL_ZOOM_DELTA;\n      const newZoom = Math.max(\n        MIN_ZOOM,\n        Math.min(MAX_ZOOM, currentViewport.zoom + zoomDelta)\n      );\n\n      // Calculate new dimensions based on new zoom\n      const newRows = Math.ceil(window.innerHeight / (CELL_SIZE * newZoom));\n      const newCols = Math.ceil(window.innerWidth / (CELL_SIZE * newZoom));\n\n      // Adjust offset to keep the same visual point fixed\n      const newOffset = {\n        x:\n          currentViewport.offset.x -\n          mouseXRatio * (newCols - currentViewport.dimensions.cols),\n        y:\n          currentViewport.offset.y -\n          mouseYRatio * (newRows - currentViewport.dimensions.rows),\n      };\n\n      // Batched update to prevent race conditions\n      setViewport({\n        zoom: newZoom,\n        offset: newOffset,\n        dimensions: { rows: newRows, cols: newCols },\n      });\n    };\n    const board = document.querySelector(\".gol-board\") as HTMLElement | null;\n    if (board) {\n      const eventHandler = handler as EventListener;\n      board.addEventListener(\"wheel\", eventHandler, { passive: false });\n      return () => board.removeEventListener(\"wheel\", eventHandler);\n    }\n    return;\n  }, [viewportRef, setViewport]);\n\n  // drag/click detection (mouse)\n  useEffect(() => {\n    let isMouseDown = false;\n    let hasDragged = false;\n    let startX = 0;\n    let startY = 0;\n    let lastX = 0;\n    let lastY = 0;\n\n    const handleMouseDown = (e: MouseEvent): void => {\n      if ((e.target as HTMLElement).closest(\".gol-controls\")) return;\n\n      isMouseDown = true;\n      hasDragged = false;\n      setIsPointerDown(true);\n      startX = e.clientX;\n      startY = e.clientY;\n      lastX = e.clientX;\n      lastY = e.clientY;\n    };\n\n    const handleMouseMove = (e: MouseEvent): void => {\n      if (!isMouseDown) return;\n\n      const dx = e.clientX - lastX;\n      const dy = e.clientY - lastY;\n\n      const totalDx = Math.abs(e.clientX - startX);\n      const totalDy = Math.abs(e.clientY - startY);\n\n      if (\n        !hasDragged &&\n        (totalDx > DRAG_THRESHOLD_PX || totalDy > DRAG_THRESHOLD_PX)\n      ) {\n        hasDragged = true;\n        isDraggingRef.current = true;\n        setIsDragging(true);\n      }\n\n      if (hasDragged) {\n        const currentViewport = viewportRef.current;\n        const board = document.querySelector(\".gol-board\") as HTMLElement;\n        const rect = board?.getBoundingClientRect();\n        if (!rect) return;\n\n        const cellDx = (dx / rect.width) * currentViewport.dimensions.cols;\n        const cellDy = (dy / rect.height) * currentViewport.dimensions.rows;\n\n        setViewport((prev) => ({\n          ...prev,\n          offset: {\n            x: prev.offset.x - cellDx,\n            y: prev.offset.y - cellDy,\n          },\n        }));\n      }\n\n      lastX = e.clientX;\n      lastY = e.clientY;\n    };\n\n    const handleMouseUp = (): void => {\n      if (hasDragged) {\n        setIsDragging(false);\n      }\n      isMouseDown = false;\n      hasDragged = false;\n      setIsPointerDown(false);\n      setTimeout(() => {\n        isDraggingRef.current = false;\n      }, 0);\n    };\n\n    const handleMouseLeave = (): void => {\n      if (isMouseDown) {\n        isMouseDown = false;\n        hasDragged = false;\n        setIsPointerDown(false);\n        setIsDragging(false);\n        isDraggingRef.current = false;\n      }\n    };\n\n    window.addEventListener(\"mousedown\", handleMouseDown);\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    window.addEventListener(\"mouseup\", handleMouseUp);\n    window.addEventListener(\"mouseleave\", handleMouseLeave);\n\n    return () => {\n      window.removeEventListener(\"mousedown\", handleMouseDown);\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n      window.removeEventListener(\"mouseup\", handleMouseUp);\n      window.removeEventListener(\"mouseleave\", handleMouseLeave);\n    };\n  }, [viewportRef, setViewport]);\n\n  // drag/tap detection (touch) & pinch zoom\n  useEffect(() => {\n    let initialDistance = 0;\n    let isTouching = false;\n    let hasDragged = false;\n    let startX = 0;\n    let startY = 0;\n    let lastX = 0;\n    let lastY = 0;\n\n    const handleTouchStart = (e: TouchEvent): void => {\n      if (e.touches.length === 2) {\n        isTouching = false;\n        hasDragged = false;\n        const dx = e.touches[0].clientX - e.touches[1].clientX;\n        const dy = e.touches[0].clientY - e.touches[1].clientY;\n        initialDistance = Math.sqrt(dx * dx + dy * dy);\n      } else if (e.touches.length === 1) {\n        isTouching = true;\n        hasDragged = false;\n        startX = e.touches[0].clientX;\n        startY = e.touches[0].clientY;\n        lastX = e.touches[0].clientX;\n        lastY = e.touches[0].clientY;\n      }\n    };\n\n    const handleTouchMove = (e: TouchEvent): void => {\n      if (e.touches.length === 2) {\n        e.preventDefault();\n        isTouching = false;\n        hasDragged = false;\n        const board = e.currentTarget as HTMLElement;\n        const rect = board.getBoundingClientRect();\n\n        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;\n        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;\n        const centerXRatio = (centerX - rect.left) / rect.width;\n        const centerYRatio = (centerY - rect.top) / rect.height;\n\n        const currentViewport = viewportRef.current;\n\n        const dx = e.touches[0].clientX - e.touches[1].clientX;\n        const dy = e.touches[0].clientY - e.touches[1].clientY;\n        const currentDistance = Math.sqrt(dx * dx + dy * dy);\n\n        // Pinch-zoom with 50% damping\n        const rawScale = currentDistance / initialDistance;\n        const scale = 1 + (rawScale - 1) * PINCH_ZOOM_DAMPING;\n        const newZoom = Math.max(\n          MIN_ZOOM,\n          Math.min(MAX_ZOOM, currentViewport.zoom * scale)\n        );\n\n        const newRows = Math.ceil(window.innerHeight / (CELL_SIZE * newZoom));\n        const newCols = Math.ceil(window.innerWidth / (CELL_SIZE * newZoom));\n\n        const newOffset = {\n          x:\n            currentViewport.offset.x -\n            centerXRatio * (newCols - currentViewport.dimensions.cols),\n          y:\n            currentViewport.offset.y -\n            centerYRatio * (newRows - currentViewport.dimensions.rows),\n        };\n\n        // Batched update to prevent race conditions\n        setViewport({\n          zoom: newZoom,\n          offset: newOffset,\n          dimensions: { rows: newRows, cols: newCols },\n        });\n      } else if (e.touches.length === 1 && isTouching) {\n        const dx = e.touches[0].clientX - lastX;\n        const dy = e.touches[0].clientY - lastY;\n\n        const totalDx = Math.abs(e.touches[0].clientX - startX);\n        const totalDy = Math.abs(e.touches[0].clientY - startY);\n\n        if (\n          !hasDragged &&\n          (totalDx > DRAG_THRESHOLD_PX || totalDy > DRAG_THRESHOLD_PX)\n        ) {\n          hasDragged = true;\n          setIsDragging(true);\n        }\n\n        if (hasDragged) {\n          e.preventDefault();\n          const currentViewport = viewportRef.current;\n          const board = document.querySelector(\".gol-board\") as HTMLElement;\n          const rect = board?.getBoundingClientRect();\n          if (!rect) return;\n\n          const cellDx = (dx / rect.width) * currentViewport.dimensions.cols;\n          const cellDy = (dy / rect.height) * currentViewport.dimensions.rows;\n\n          setViewport((prev) => ({\n            ...prev,\n            offset: {\n              x: prev.offset.x - cellDx,\n              y: prev.offset.y - cellDy,\n            },\n          }));\n        }\n\n        lastX = e.touches[0].clientX;\n        lastY = e.touches[0].clientY;\n      }\n    };\n\n    const handleTouchEnd = (): void => {\n      isTouching = false;\n      setIsDragging(false);\n    };\n\n    const board = document.querySelector(\".gol-board\");\n    if (board) {\n      const startHandler = handleTouchStart as EventListener;\n      const moveHandler = handleTouchMove as EventListener;\n      const endHandler = handleTouchEnd as EventListener;\n\n      board.addEventListener(\"touchstart\", startHandler);\n      board.addEventListener(\"touchmove\", moveHandler, { passive: false });\n      board.addEventListener(\"touchend\", endHandler);\n\n      return () => {\n        board.removeEventListener(\"touchstart\", startHandler);\n        board.removeEventListener(\"touchmove\", moveHandler);\n        board.removeEventListener(\"touchend\", endHandler);\n      };\n    }\n  }, [viewportRef, setViewport]);\n\n  return {\n    isDraggingRef,\n    isDragging,\n    isPointerDown,\n  };\n}\n"],"names":["DEFAULT_TICK_PER_SEC","MAX_TICK_PER_SEC","CELL_SIZE","MIN_ZOOM","MAX_ZOOM","DRAG_THRESHOLD_PX","MAX_LIVE_CELLS","CULLING_MARGIN","COORD_OFFSET","KEY_MULTIPLIER","LIFE_NEIGHBORS_BIRTH","COLOR_GOLD","WHEEL_ZOOM_DELTA","PINCH_ZOOM_DAMPING","ZOOM_DEFAULT_LEVEL","EXTRA_ROWS","Cell","memo","_ref","x","y","filled","_jsx","className","concat","style","backgroundColor","undefined","parsePattern","art","lines","trim","split","coords","forEach","line","length","push","displayName","TABLE","HOLLOW_SQUARES","GLIDER_GUN","ONE_TWO_THREE","PATTERNS","name","pattern","makeKey","parseKey","k","Math","floor","useGameLogic","_ref2","liveCellsRef","viewportRef","ticksPerSec","setGeneration","setTickCount","setRunning","runningRef","useRef","animationFrameRef","lastTickTimeRef","growthCountRef","runTick","useCallback","timestamp","arguments","performance","now","current","requestAnimationFrame","currentSize","size","alert","g","checkCellLimit","bounds","currentViewport","minX","offset","maxX","dimensions","cols","minY","maxY","rows","computeViewportBounds","nextGen","neighbourCounter","liveCells","Set","count","cellKey","alive","has","add","applyRules","Map","dy","dx","neighKey","set","get","countNeighbours","nextGenSize","console","warn","growthDetection","t","useEffect","cancelAnimationFrame","GameOfLifeInfinite","_currentPattern$name","CONSTANTS","initialRows","ceil","window","innerHeight","initialCols","innerWidth","initialLive","patternCenterX","patternCenterY","selectedPattern","useState","randomIndex","random","log","patterns","live","map","patternBounds","min","max","_ref3","_ref4","_ref5","viewport","setViewport","zoom","viewRows","viewCols","handleResize","_objectSpread","addEventListener","removeEventListener","generation","tickCount","tickCountRef","showSplash","setShowSplash","fadingSplash","setFadingSplash","resetClicked","setResetClicked","currentPattern","setCurrentPattern","resetStateRef","resetOffsetRef","resetTickCountRef","isFullscreen","setIsFullscreen","showInfo","setShowInfo","wasRunningBeforeInfoRef","handleFullscreenChange","document","fullscreenElement","handleEscapeKey","e","key","preventDefault","stopPropagation","stopImmediatePropagation","capture","toggleFullscreen","exitFullscreen","documentElement","requestFullscreen","catch","err","error","fadeTimer","setTimeout","removeTimer","clearTimeout","running","toggleCell","isDraggingRef","delete","loadPattern","newLive","_ref6","newOffset","_ref7","_ref8","_ref9","_ref0","centerX","centerY","resetBoard","onToggleStart","newRunning","isDragging","isPointerDown","setIsDragging","setIsPointerDown","handler","v","rect","currentTarget","getBoundingClientRect","mouseXRatio","clientX","left","width","mouseYRatio","clientY","top","height","zoomDelta","deltaY","newZoom","newRows","newCols","board","querySelector","eventHandler","passive","isMouseDown","hasDragged","startX","startY","lastX","lastY","handleMouseDown","target","closest","handleMouseMove","totalDx","abs","totalDy","cellDx","cellDy","prev","handleMouseUp","handleMouseLeave","initialDistance","isTouching","handleTouchStart","touches","sqrt","handleTouchMove","centerXRatio","centerYRatio","scale","handleTouchEnd","startHandler","moveHandler","endHandler","useInteractions","offsetX","offsetY","fractionalX","fractionalY","handleBoardClick","classList","contains","getAttribute","Number","useMemo","result","r","cells","c","cellX","cellY","children","_jsxs","id","onClick","transform","value","onChange","find","p","type","step","raw","n","title","display","flexDirection","lineHeight","fontSize"],"sourceRoot":""}