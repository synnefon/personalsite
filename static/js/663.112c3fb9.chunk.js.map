{"version":3,"file":"static/js/663.112c3fb9.chunk.js","mappings":"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","sources":["shufflenator/shuffleWorker.js"],"sourcesContent":["// Self-contained web worker for shuffle computation.\n// All logic is inlined to avoid import issues in worker context.\n\n// --- Scorers ---\n\nfunction calcAdjacentTermDifferences(cards) {\n    const deckLen = cards.length;\n    const diffs = [];\n    for (let idx = 0; idx < deckLen; idx++) {\n        let diff = cards[(idx + 1) % deckLen] - cards[idx];\n        if (diff < 0) diff += deckLen;\n        diffs.push(diff);\n    }\n    return diffs;\n}\n\nfunction calcAverageNeighborDist(cards) {\n    return calcAdjacentTermDifferences(cards).reduce((a, b) => a + b, 0) / cards.length;\n}\n\nfunction calcLocationDelta(cards) {\n    let total = 0;\n    for (let idx = 0; idx < cards.length; idx++) {\n        total += Math.abs(idx - cards[idx]);\n    }\n    return total / cards.length;\n}\n\nfunction calcShannonEntropy(cards) {\n    const diffs = calcAdjacentTermDifferences(cards);\n    const counts = {};\n    for (const d of diffs) counts[d] = (counts[d] || 0) + 1;\n    const pCounts = Object.values(counts).map(c => c / cards.length);\n    return pCounts.map(p => Math.abs(Math.log(p) * p)).filter(p => p > 0).reduce((a, b) => a + b, 0);\n}\n\nconst SCORE_FUNCTION_MAP = {\n    \"SHANNON_ENTROPY\": calcShannonEntropy,\n    \"NEIGHBOR_DIST\": calcAverageNeighborDist,\n    \"LOCATION_DELTA\": calcLocationDelta,\n};\n\n// --- Shuffler ---\n\nfunction makeShuffledDeck(cardList, permutation, scoreType) {\n    return {\n        cardList,\n        permutation,\n        score: SCORE_FUNCTION_MAP[scoreType](cardList),\n        key: cardList.join(','),\n    };\n}\n\nfunction shuffle(pileSelector, deck, numPiles, scoreType) {\n    const piles = Array.from({ length: numPiles }, () => []);\n    for (let idx = 0; idx < deck.cardList.length; idx++) {\n        piles[pileSelector(idx)].unshift(deck.cardList[idx]);\n    }\n    return makeShuffledDeck(piles.flat(), [...deck.permutation, numPiles], scoreType);\n}\n\nfunction pileShuffle(deck, numPiles, scoreType) {\n    const cards = deck.cardList;\n    const len = cards.length;\n    const result = new Array(len);\n    const full = Math.floor(len / numPiles);\n    const remainder = len % numPiles;\n    let offset = 0;\n    const pileStart = new Array(numPiles);\n    const pileSize = new Array(numPiles);\n    for (let p = 0; p < numPiles; p++) {\n        pileStart[p] = offset;\n        pileSize[p] = p < remainder ? full + 1 : full;\n        offset += pileSize[p];\n    }\n    const writePos = new Array(numPiles);\n    for (let p = 0; p < numPiles; p++) {\n        writePos[p] = pileStart[p] + pileSize[p] - 1;\n    }\n    for (let idx = 0; idx < len; idx++) {\n        const p = idx % numPiles;\n        result[writePos[p]] = cards[idx];\n        writePos[p]--;\n    }\n    return makeShuffledDeck(result, [...deck.permutation, numPiles], scoreType);\n}\n\nfunction randomPileShuffle(deck, numPiles, scoreType) {\n    return shuffle(() => Math.floor(Math.random() * numPiles), deck, numPiles, scoreType);\n}\n\nconst SHUFFLE_FUNCTION_MAP = {\n    \"PILE\": pileShuffle,\n    \"RANDOM_PILE\": randomPileShuffle,\n};\n\n// --- Simulator ---\n// eslint-disable-next-line no-restricted-globals\nconst workerScope = self;\n\nworkerScope.onmessage = (e) => {\n    const { shuffleStrat, scoreType, maxShuffles, deckSize, minNumPiles, maxNumPiles } = e.data;\n    const pileDivisions = Array.from({ length: maxNumPiles - minNumPiles + 1 }, (_, i) => i + minNumPiles);\n    const shuffleFunction = SHUFFLE_FUNCTION_MAP[shuffleStrat];\n\n    const seen = new Set();\n    const baseCardList = Array.from({ length: deckSize }, (_, i) => i);\n    const baseDeck = makeShuffledDeck(baseCardList, [], scoreType);\n    seen.add(baseDeck.key);\n    let frontier = [baseDeck];\n    let best = null;\n\n    for (let round = 0; round < maxShuffles; round++) {\n        const roundTotal = frontier.length * pileDivisions.length;\n        const nextFrontier = [];\n\n        for (let j = 0; j < frontier.length; j++) {\n            const deck = frontier[j];\n            for (const numPiles of pileDivisions) {\n                const newDeck = shuffleFunction(deck, numPiles, scoreType);\n                if (!seen.has(newDeck.key)) {\n                    seen.add(newDeck.key);\n                    nextFrontier.push(newDeck);\n                    if (!best || newDeck.score > best.score) best = newDeck;\n                }\n            }\n            if (j % 50 === 0) {\n                workerScope.postMessage({\n                    type: 'progress',\n                    completed: (j + 1) * pileDivisions.length,\n                    total: roundTotal,\n                    round: round + 1,\n                });\n            }\n        }\n\n        // free old frontier keys from deck objects\n        for (const deck of frontier) { delete deck.key; }\n        frontier = nextFrontier;\n\n        workerScope.postMessage({\n            type: 'progress',\n            completed: roundTotal,\n            total: roundTotal,\n            round: round + 1,\n        });\n    }\n\n    workerScope.postMessage({\n        type: 'result',\n        data: best ? { permutation: best.permutation, score: best.score } : null,\n    });\n};\n"],"names":["calcAdjacentTermDifferences","cards","deckLen","length","diffs","idx","diff","push","SCORE_FUNCTION_MAP","counts","d","Object","values","map","c","p","Math","abs","log","filter","reduce","a","b","total","makeShuffledDeck","cardList","permutation","scoreType","score","key","join","SHUFFLE_FUNCTION_MAP","deck","numPiles","len","result","Array","full","floor","remainder","offset","pileStart","pileSize","writePos","pileSelector","piles","from","unshift","flat","shuffle","random","workerScope","self","onmessage","e","shuffleStrat","maxShuffles","deckSize","minNumPiles","maxNumPiles","data","pileDivisions","_","i","shuffleFunction","seen","Set","baseDeck","add","frontier","best","round","roundTotal","nextFrontier","j","newDeck","has","postMessage","type","completed"],"sourceRoot":""}