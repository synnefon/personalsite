{"version":3,"file":"static/js/663.162cc74f.chunk.js","mappings":"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","sources":["shufflenator/shuffleWorker.js"],"sourcesContent":["// Self-contained web worker for shuffle computation.\n// All logic is inlined to avoid import issues in worker context.\n\n// --- Scorers ---\n\nfunction calcAverageNeighborDist(cards) {\n    const deckLen = cards.length;\n    let total = 0;\n    for (let idx = 0; idx < deckLen; idx++) {\n        let diff = cards[(idx + 1) % deckLen] - cards[idx];\n        if (diff < 0) diff += deckLen;\n        total += diff;\n    }\n    return total / deckLen;\n}\n\nfunction calcLocationDelta(cards) {\n    let total = 0;\n    for (let idx = 0; idx < cards.length; idx++) {\n        total += Math.abs(idx - cards[idx]);\n    }\n    return total / cards.length;\n}\n\nfunction calcShannonEntropy(cards) {\n    const deckLen = cards.length;\n    const counts = {};\n    for (let idx = 0; idx < deckLen; idx++) {\n        let diff = cards[(idx + 1) % deckLen] - cards[idx];\n        if (diff < 0) diff += deckLen;\n        counts[diff] = (counts[diff] || 0) + 1;\n    }\n    let entropy = 0;\n    for (const key in counts) {\n        const p = counts[key] / deckLen;\n        entropy += Math.abs(Math.log(p) * p);\n    }\n    return entropy;\n}\n\nconst SCORE_FUNCTION_MAP = {\n    \"SHANNON_ENTROPY\": calcShannonEntropy,\n    \"NEIGHBOR_DIST\": calcAverageNeighborDist,\n    \"LOCATION_DELTA\": calcLocationDelta,\n};\n\n// --- Shuffler ---\n\nfunction makeShuffledDeck(cardList, permutation, scoreType) {\n    return {\n        cardList,\n        permutation,\n        score: SCORE_FUNCTION_MAP[scoreType](cardList),\n    };\n}\n\nfunction shuffle(pileSelector, deck, numPiles, scoreType) {\n    const piles = Array.from({ length: numPiles }, () => []);\n    for (let idx = 0; idx < deck.cardList.length; idx++) {\n        piles[pileSelector(idx)].unshift(deck.cardList[idx]);\n    }\n    return makeShuffledDeck(piles.flat(), [...deck.permutation, numPiles], scoreType);\n}\n\nfunction pileShuffle(deck, numPiles, scoreType) {\n    const cards = deck.cardList;\n    const len = cards.length;\n    const result = new Array(len);\n    const full = Math.floor(len / numPiles);\n    const remainder = len % numPiles;\n    let offset = 0;\n    const pileStart = new Array(numPiles);\n    const pileSize = new Array(numPiles);\n    for (let p = 0; p < numPiles; p++) {\n        pileStart[p] = offset;\n        pileSize[p] = p < remainder ? full + 1 : full;\n        offset += pileSize[p];\n    }\n    const writePos = new Array(numPiles);\n    for (let p = 0; p < numPiles; p++) {\n        writePos[p] = pileStart[p] + pileSize[p] - 1;\n    }\n    for (let idx = 0; idx < len; idx++) {\n        const p = idx % numPiles;\n        result[writePos[p]] = cards[idx];\n        writePos[p]--;\n    }\n    return makeShuffledDeck(result, [...deck.permutation, numPiles], scoreType);\n}\n\nfunction randomPileShuffle(deck, numPiles, scoreType) {\n    return shuffle(() => Math.floor(Math.random() * numPiles), deck, numPiles, scoreType);\n}\n\nconst SHUFFLE_FUNCTION_MAP = {\n    \"PILE\": pileShuffle,\n    \"RANDOM_PILE\": randomPileShuffle,\n};\n\n// --- Simulator ---\n// eslint-disable-next-line no-restricted-globals\nconst workerScope = self;\n\nworkerScope.onmessage = (e) => {\n    const { shuffleStrat, scoreType, maxShuffles, deckSize, minNumPiles, maxNumPiles } = e.data;\n    const pileDivisions = Array.from({ length: maxNumPiles - minNumPiles + 1 }, (_, i) => i + minNumPiles);\n    const shuffleFunction = SHUFFLE_FUNCTION_MAP[shuffleStrat];\n    const numOptions = pileDivisions.length;\n\n    const baseCardList = Array.from({ length: deckSize }, (_, i) => i);\n    const baseDeck = makeShuffledDeck(baseCardList, [], scoreType);\n\n    let totalNodes = 0;\n    for (let d = 1; d <= maxShuffles; d++) totalNodes += Math.pow(numOptions, d);\n\n    let nodesVisited = 0;\n    let best = null;\n\n    // Iterative DFS â€” stack stays at O(maxShuffles * numOptions) entries max,\n    // vs BFS frontier which grows as O(numOptions^round).\n    const stack = [{ deck: baseDeck, depth: 0 }];\n\n    function processChunk() {\n        const start = performance.now();\n\n        while (stack.length > 0) {\n            const { deck, depth } = stack.pop();\n\n            if (depth > 0) {\n                nodesVisited++;\n                if (!best || deck.score > best.score) {\n                    best = { permutation: [...deck.permutation], score: deck.score };\n                }\n            }\n\n            if (depth < maxShuffles) {\n                for (let i = numOptions - 1; i >= 0; i--) {\n                    const child = shuffleFunction(deck, pileDivisions[i], scoreType);\n                    stack.push({ deck: child, depth: depth + 1 });\n                }\n            }\n\n            if (performance.now() - start > 200) {\n                workerScope.postMessage({\n                    type: 'progress',\n                    completed: nodesVisited,\n                    total: totalNodes,\n                    round: 1,\n                });\n                setTimeout(processChunk, 0);\n                return;\n            }\n        }\n\n        workerScope.postMessage({\n            type: 'result',\n            data: best ? { permutation: best.permutation, score: best.score } : null,\n        });\n    }\n\n    processChunk();\n};\n"],"names":["SCORE_FUNCTION_MAP","cards","deckLen","length","counts","idx","diff","entropy","key","p","Math","abs","log","total","makeShuffledDeck","cardList","permutation","scoreType","score","SHUFFLE_FUNCTION_MAP","deck","numPiles","len","result","Array","full","floor","remainder","offset","pileStart","pileSize","writePos","pileSelector","piles","from","unshift","flat","shuffle","random","workerScope","self","onmessage","e","shuffleStrat","maxShuffles","deckSize","minNumPiles","maxNumPiles","data","pileDivisions","_","i","shuffleFunction","numOptions","baseDeck","totalNodes","d","pow","nodesVisited","best","stack","depth","processChunk","start","performance","now","pop","child","push","postMessage","type","completed","round","setTimeout"],"sourceRoot":""}