{"version":3,"file":"static/js/663.a6594c05.chunk.js","mappings":"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","sources":["shufflenator/shuffleWorker.js"],"sourcesContent":["// Self-contained web worker for shuffle computation.\n// All logic is inlined to avoid import issues in worker context.\n\n// --- Scorers ---\n\nfunction calcAverageNeighborDist(cards) {\n    const deckLen = cards.length;\n    let total = 0;\n    for (let idx = 0; idx < deckLen; idx++) {\n        let diff = cards[(idx + 1) % deckLen] - cards[idx];\n        if (diff < 0) diff += deckLen;\n        total += diff;\n    }\n    return total / deckLen;\n}\n\nfunction calcLocationDelta(cards) {\n    let total = 0;\n    for (let idx = 0; idx < cards.length; idx++) {\n        total += Math.abs(idx - cards[idx]);\n    }\n    return total / cards.length;\n}\n\nlet entropyCounts = null;\nlet entropySlots = null;\nlet entropyLookup = null;\n\nfunction calcShannonEntropy(cards) {\n    const deckLen = cards.length;\n    if (!entropyCounts || entropyCounts.length < deckLen) {\n        entropyCounts = new Uint32Array(deckLen);\n        entropySlots = new Uint16Array(deckLen);\n        entropyLookup = new Float64Array(deckLen + 1);\n        for (let k = 1; k <= deckLen; k++) {\n            const p = k / deckLen;\n            entropyLookup[k] = -Math.log(p) * p;\n        }\n    }\n    let usedCount = 0;\n    for (let idx = 0; idx < deckLen - 1; idx++) {\n        let diff = cards[idx + 1] - cards[idx];\n        if (diff < 0) diff += deckLen;\n        if (entropyCounts[diff] === 0) entropySlots[usedCount++] = diff;\n        entropyCounts[diff]++;\n    }\n    let diff = cards[0] - cards[deckLen - 1];\n    if (diff < 0) diff += deckLen;\n    if (entropyCounts[diff] === 0) entropySlots[usedCount++] = diff;\n    entropyCounts[diff]++;\n\n    let entropy = 0;\n    for (let i = 0; i < usedCount; i++) {\n        const slot = entropySlots[i];\n        entropy += entropyLookup[entropyCounts[slot]];\n        entropyCounts[slot] = 0;\n    }\n    return entropy;\n}\n\nconst SCORE_FUNCTION_MAP = {\n    \"SHANNON_ENTROPY\": calcShannonEntropy,\n    \"NEIGHBOR_DIST\": calcAverageNeighborDist,\n    \"LOCATION_DELTA\": calcLocationDelta,\n};\n\n// --- Profiling ---\nlet tShuffle = 0, tScore = 0, tSpread = 0, tStackOps = 0, tTimeCheck = 0;\n\n// --- Precomputed maps (populated per run) ---\nlet permMaps = {};\n\n// --- Shuffler ---\n\nfunction makeShuffledDeck(cardList, permutation, scoreType) {\n    const t0 = performance.now();\n    const score = SCORE_FUNCTION_MAP[scoreType](cardList);\n    tScore += performance.now() - t0;\n\n    return { cardList, permutation, score };\n}\n\nfunction shuffle(pileSelector, deck, numPiles, scoreType) {\n    const piles = Array.from({ length: numPiles }, () => []);\n    for (let idx = 0; idx < deck.cardList.length; idx++) {\n        piles[pileSelector(idx)].unshift(deck.cardList[idx]);\n    }\n    return makeShuffledDeck(piles.flat(), deck.permutation.concat(numPiles), scoreType);\n}\n\nfunction pileShuffle(deck, numPiles, scoreType) {\n    const t0 = performance.now();\n    const cards = deck.cardList;\n    const len = cards.length;\n    const map = permMaps[numPiles];\n    const result = new Array(len);\n    for (let i = 0; i < len; i++) {\n        result[map[i]] = cards[i];\n    }\n    const t1 = performance.now();\n    tShuffle += t1 - t0;\n\n    const t2 = performance.now();\n    const perm = deck.permutation.concat(numPiles);\n    tSpread += performance.now() - t2;\n\n    return makeShuffledDeck(result, perm, scoreType);\n}\n\nfunction randomPileShuffle(deck, numPiles, scoreType) {\n    return shuffle(() => Math.floor(Math.random() * numPiles), deck, numPiles, scoreType);\n}\n\nconst SHUFFLE_FUNCTION_MAP = {\n    \"PILE\": pileShuffle,\n    \"RANDOM_PILE\": randomPileShuffle,\n};\n\n// --- Simulator ---\n// eslint-disable-next-line no-restricted-globals\nconst workerScope = self;\n\nworkerScope.onmessage = (e) => {\n    const { shuffleStrat, scoreType, maxShuffles, deckSize, minNumPiles, maxNumPiles } = e.data;\n    console.log(`[params] deck=${deckSize} piles=${minNumPiles}-${maxNumPiles} rounds=${maxShuffles} strat=${shuffleStrat} score=${scoreType}`);\n    const pileDivisions = Array.from({ length: maxNumPiles - minNumPiles + 1 }, (_, i) => i + minNumPiles);\n    const shuffleFunction = SHUFFLE_FUNCTION_MAP[shuffleStrat];\n    const numOptions = pileDivisions.length;\n\n    // Precompute permutation index maps for each pile count\n    permMaps = {};\n    for (const numPiles of pileDivisions) {\n        const map = new Int32Array(deckSize);\n        const full = Math.floor(deckSize / numPiles);\n        const remainder = deckSize % numPiles;\n        let offset = 0;\n        const pileStart = new Array(numPiles);\n        const pileSz = new Array(numPiles);\n        for (let p = 0; p < numPiles; p++) {\n            pileStart[p] = offset;\n            pileSz[p] = p < remainder ? full + 1 : full;\n            offset += pileSz[p];\n        }\n        const writePos = new Array(numPiles);\n        for (let p = 0; p < numPiles; p++) {\n            writePos[p] = pileStart[p] + pileSz[p] - 1;\n        }\n        for (let idx = 0; idx < deckSize; idx++) {\n            map[idx] = writePos[idx % numPiles];\n            writePos[idx % numPiles]--;\n        }\n        permMaps[numPiles] = map;\n    }\n\n    const baseCardList = Array.from({ length: deckSize }, (_, i) => i);\n    const baseDeck = makeShuffledDeck(baseCardList, [], scoreType);\n\n    let totalNodes = 0;\n    for (let d = 1; d <= maxShuffles; d++) totalNodes += Math.pow(numOptions, d);\n\n    let nodesVisited = 0;\n    let best = null;\n\n    // Iterative DFS â€” stack stays at O(maxShuffles * numOptions) entries max,\n    // vs BFS frontier which grows as O(numOptions^round).\n    const stack = [{ deck: baseDeck, depth: 0 }];\n\n    tShuffle = 0; tScore = 0; tSpread = 0; tStackOps = 0; tTimeCheck = 0;\n\n    function processChunk() {\n        const start = performance.now();\n\n        while (stack.length > 0) {\n            let t0, t1;\n\n            t0 = performance.now();\n            const { deck, depth } = stack.pop();\n            t1 = performance.now();\n            tStackOps += t1 - t0;\n\n            if (depth > 0) {\n                nodesVisited++;\n                if (!best || deck.score > best.score) {\n                    best = { permutation: [...deck.permutation], score: deck.score };\n                }\n            }\n\n            if (depth < maxShuffles) {\n                for (let i = numOptions - 1; i >= 0; i--) {\n                    const child = shuffleFunction(deck, pileDivisions[i], scoreType);\n\n                    t0 = performance.now();\n                    stack.push({ deck: child, depth: depth + 1 });\n                    tStackOps += performance.now() - t0;\n                }\n            }\n\n            t0 = performance.now();\n            const elapsed = t0 - start;\n            tTimeCheck += performance.now() - t0;\n\n            if (elapsed > 200) {\n                workerScope.postMessage({\n                    type: 'progress',\n                    completed: nodesVisited,\n                    total: totalNodes,\n                    round: 1,\n                });\n                console.log(\n                    `[profile] nodes=${nodesVisited} | shuffle=${tShuffle.toFixed(0)}ms score=${tScore.toFixed(0)}ms spread=${tSpread.toFixed(0)}ms | stackOps=${tStackOps.toFixed(0)}ms timeCheck=${tTimeCheck.toFixed(0)}ms`\n                );\n                setTimeout(processChunk, 0);\n                return;\n            }\n        }\n\n        console.log(\n            `[profile FINAL] nodes=${nodesVisited} | shuffle=${tShuffle.toFixed(0)}ms score=${tScore.toFixed(0)}ms spread=${tSpread.toFixed(0)}ms | stackOps=${tStackOps.toFixed(0)}ms timeCheck=${tTimeCheck.toFixed(0)}ms`\n        );\n        workerScope.postMessage({\n            type: 'result',\n            data: best ? { permutation: best.permutation, score: best.score } : null,\n        });\n    }\n\n    processChunk();\n};\n"],"names":["entropyCounts","entropySlots","entropyLookup","SCORE_FUNCTION_MAP","cards","deckLen","length","Uint32Array","Uint16Array","Float64Array","k","p","Math","log","usedCount","idx","diff","entropy","i","slot","total","abs","tShuffle","tScore","tSpread","tStackOps","tTimeCheck","permMaps","makeShuffledDeck","cardList","permutation","scoreType","t0","performance","now","score","SHUFFLE_FUNCTION_MAP","deck","numPiles","len","map","result","Array","t1","t2","perm","concat","pileSelector","piles","from","unshift","flat","shuffle","floor","random","workerScope","self","onmessage","e","shuffleStrat","maxShuffles","deckSize","minNumPiles","maxNumPiles","data","console","pileDivisions","_","shuffleFunction","numOptions","Int32Array","full","remainder","offset","pileStart","pileSz","writePos","baseDeck","totalNodes","d","pow","nodesVisited","best","stack","depth","processChunk","start","pop","child","push","elapsed","postMessage","type","completed","round","toFixed","setTimeout"],"sourceRoot":""}