{"version":3,"file":"static/js/399.e934faa8.chunk.js","mappings":"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","sources":["lava_lamp/LavaLamp.tsx"],"sourcesContent":["import React, {\n  ReactElement,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport \"../styles/lavalamp.css\";\n\n// --- Types ---\ninterface Particle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  heat: number;\n}\n\n// --- Constants ---\nconst PARTICLE_COUNT = 500;\nconst GRAVITY = 0.01;\nconst BUOYANCY = 0.04;\nconst FRICTION = 0.98;\nconst HEAT_RATE = 0.005;\nconst COOL_RATE = 0.0028;\nconst HEAT_CONDUCTION = 0.002;\nconst HEAT_SOURCE_DISTANCE = 40;\nconst COHESION_RADIUS = 25;\nconst COHESION_STRENGTH = 0.003;\nconst PARTICLE_RADIUS = 10;\nconst PIXEL_SIZE = 6;\n\nexport default function LavaLamp(): ReactElement {\n  // --- Refs and State ---\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const animationFrameRef = useRef<number | null>(null);\n  const particlesRef = useRef<Particle[]>([]);\n  const [running, setRunning] = useState(true);\n  const mouseDownRef = useRef(false);\n  const mousePositionRef = useRef({ x: 0, y: 0 });\n\n  // --- Particle Initialization ---\n  const initializeParticles = useCallback((): Particle[] => {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    const particles: Particle[] = [];\n\n    // Create random clumps of particles\n    const clumpCount = 15;\n    const particlesPerClump = Math.floor(PARTICLE_COUNT / clumpCount);\n    const clumpRadius = 50;\n\n    for (let i = 0; i < clumpCount; i++) {\n      // Random clump center and heat - 30% in top half, 70% in bottom half\n      const centerX = Math.random() * width;\n      const centerY = Math.random() < 0.3\n        ? Math.random() * height * 0.5 // 30% chance: top half\n        : height * 0.5 + Math.random() * height * 0.5; // 70% chance: bottom half\n      const clumpHeat = Math.random(); // Random heat from 0 to 1\n\n      for (let j = 0; j < particlesPerClump; j++) {\n        // Random position within clump radius\n        const angle = Math.random() * Math.PI * 2;\n        const dist = Math.random() * clumpRadius;\n\n        particles.push({\n          x: centerX + Math.cos(angle) * dist,\n          y: centerY + Math.sin(angle) * dist,\n          vx: 0,\n          vy: 0,\n          heat: clumpHeat,\n        });\n      }\n    }\n\n    // Fill remaining particles randomly\n    while (particles.length < PARTICLE_COUNT) {\n      particles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: 0,\n        vy: 0,\n        heat: 0,\n      });\n    }\n\n    return particles;\n  }, []);\n\n  // --- Populate particles once on mount/resize ---\n  useEffect(() => {\n    particlesRef.current = initializeParticles();\n  }, [initializeParticles]);\n\n  // --- Physics Update ---\n  const updateParticles = useCallback(() => {\n    const particles = particlesRef.current;\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    // Helper: Get neighbor count for each particle\n    const neighborCounts = particles.map((p1) =>\n      particles.filter(\n        (p2) =>\n          p1 !== p2 &&\n          Math.hypot(p2.x - p1.x, p2.y - p1.y) < COHESION_RADIUS\n      ).length\n    );\n\n    for (let i = 0; i < particles.length; i++) {\n      const p = particles[i];\n\n      // Gravity and buoyancy\n      const buoyancy = Math.pow(p.heat, 2) * BUOYANCY;\n      p.vy += GRAVITY - buoyancy;\n\n      // Friction\n      p.vx *= FRICTION;\n      p.vy *= FRICTION;\n\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n\n      // Mouse heating - apply heat when clicking\n      if (mouseDownRef.current) {\n        const distanceFromMouse = Math.hypot(\n          p.x - mousePositionRef.current.x,\n          p.y - mousePositionRef.current.y\n        );\n        const mouseHeatRadius = 100;\n        if (distanceFromMouse < mouseHeatRadius) {\n          const heatIntensity = 1 - distanceFromMouse / mouseHeatRadius;\n          p.heat += HEAT_RATE * 2 * heatIntensity; // 2x heat rate for mouse\n        }\n      }\n\n      // Heat logic\n      const distanceFromBottom = height - p.y;\n      if (distanceFromBottom < HEAT_SOURCE_DISTANCE) {\n        // Heating near bottom\n        const heatIntensity = 1 - distanceFromBottom / HEAT_SOURCE_DISTANCE;\n        p.heat += HEAT_RATE * heatIntensity;\n      } else {\n        // Cooling by air exposure (proportional to number of neighbors)\n        const maxNeighbors = 8;\n        const airExposure =\n          1 - Math.min(neighborCounts[i], maxNeighbors) / maxNeighbors;\n        p.heat -= COOL_RATE * (0.2 + airExposure * 0.8);\n      }\n      // Clamp heat\n      p.heat = Math.max(0, Math.min(1, p.heat));\n\n      // Boundaries (bounce)\n      if (p.x < 0) {\n        p.x = 0;\n        p.vx *= -0.5;\n      } else if (p.x > width) {\n        p.x = width;\n        p.vx *= -0.5;\n      }\n      if (p.y < 0) {\n        p.y = 0;\n        p.vy *= -0.5;\n      } else if (p.y > height) {\n        p.y = height;\n        p.vy *= -0.5;\n      }\n    }\n\n    // --- Cohesion and Heat Conduction ---\n    for (let i = 0; i < particles.length; i++) {\n      const p1 = particles[i];\n      for (let j = i + 1; j < particles.length; j++) {\n        const p2 = particles[j];\n        const dx = p2.x - p1.x;\n        const dy = p2.y - p1.y;\n        const dist = Math.hypot(dx, dy);\n\n        if (dist > 0 && dist < COHESION_RADIUS) {\n          // Attract\n          const force = COHESION_STRENGTH * (1 - dist / COHESION_RADIUS);\n          const fx = (dx / dist) * force;\n          const fy = (dy / dist) * force;\n          p1.vx += fx;\n          p1.vy += fy;\n          p2.vx -= fx;\n          p2.vy -= fy;\n\n          // Heat conduction (from hotter to colder)\n          const heatDiff = p1.heat - p2.heat;\n          const conduction = heatDiff * HEAT_CONDUCTION;\n          p1.heat -= conduction;\n          p2.heat += conduction;\n        }\n      }\n    }\n  }, []);\n\n  // --- Metaball Render (pixellated) ---\n  const render = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n    const particles = particlesRef.current;\n\n    // Black background\n    ctx.fillStyle = \"#000\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Prepare image buffer\n    const imageData = ctx.createImageData(canvas.width, canvas.height);\n    const data = imageData.data;\n\n    // Each PIXEL_SIZE \"block\"\n    for (let y = 0; y < canvas.height; y += PIXEL_SIZE) {\n      for (let x = 0; x < canvas.width; x += PIXEL_SIZE) {\n        let influenceSum = 0;\n        let heatSum = 0;\n\n        // Sum up contributions from all particles (metaball field)\n        for (const p of particles) {\n          const dx = x - p.x;\n          const dy = y - p.y;\n          const distSq = dx * dx + dy * dy;\n          const influence =\n            (PARTICLE_RADIUS * PARTICLE_RADIUS) / (distSq + 1);\n          influenceSum += influence;\n          heatSum += influence * p.heat;\n        }\n\n        if (influenceSum > 0.8) {\n          const heat = heatSum / influenceSum;\n\n          // Color: cool = purple/blue, hot = yellow\n          const r = Math.floor(100 + heat * 155);\n          const g = Math.floor(50 + heat * 205);\n          const b = Math.floor(200 - heat * 200);\n\n          // Fill blocks with color\n          for (let py = 0; py < PIXEL_SIZE; py++) {\n            const yy = y + py;\n            if (yy >= canvas.height) continue;\n            for (let px = 0; px < PIXEL_SIZE; px++) {\n              const xx = x + px;\n              if (xx >= canvas.width) continue;\n              const idx = (yy * canvas.width + xx) * 4;\n              data[idx + 0] = r;\n              data[idx + 1] = g;\n              data[idx + 2] = b;\n              data[idx + 3] = 255;\n            }\n          }\n        }\n      }\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n  }, []);\n\n  // --- Animation Loop ---\n  const animate = useCallback(() => {\n    if (!running) return;\n    updateParticles();\n    render();\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [running, updateParticles, render]);\n\n  useEffect(() => {\n    if (running) {\n      animationFrameRef.current = requestAnimationFrame(animate);\n    } else if (animationFrameRef.current !== null) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n    return () => {\n      if (animationFrameRef.current !== null) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [running, animate]);\n\n  // --- Resize Handler ---\n  useEffect(() => {\n    function handleResize() {\n      if (!canvasRef.current) return;\n      canvasRef.current.width = window.innerWidth;\n      canvasRef.current.height = window.innerHeight;\n      particlesRef.current = initializeParticles();\n    }\n    handleResize();\n    window.addEventListener(\"resize\", handleResize);\n    return () =>\n      window.removeEventListener(\"resize\", handleResize);\n  }, [initializeParticles]);\n\n  // --- Mouse Handlers ---\n  const handleMouseDown = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {\n    mouseDownRef.current = true;\n    mousePositionRef.current = { x: e.clientX, y: e.clientY };\n  }, []);\n\n  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {\n    mousePositionRef.current = { x: e.clientX, y: e.clientY };\n  }, []);\n\n  const handleMouseUp = useCallback(() => {\n    mouseDownRef.current = false;\n  }, []);\n\n  const handleTouchStart = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {\n    if (e.touches.length > 0) {\n      mouseDownRef.current = true;\n      mousePositionRef.current = {\n        x: e.touches[0].clientX,\n        y: e.touches[0].clientY\n      };\n    }\n  }, []);\n\n  const handleTouchMove = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {\n    if (e.touches.length > 0) {\n      mousePositionRef.current = {\n        x: e.touches[0].clientX,\n        y: e.touches[0].clientY\n      };\n    }\n  }, []);\n\n  const handleTouchEnd = useCallback(() => {\n    mouseDownRef.current = false;\n  }, []);\n\n  // --- Button Handlers ---\n  const toggleRunning = useCallback(() => setRunning((p) => !p), []);\n  const reset = useCallback(() => {\n    particlesRef.current = initializeParticles();\n    render();\n  }, [initializeParticles, render]);\n\n  // --- Render UI ---\n  return (\n    <div className=\"lava-lamp-container\">\n      <canvas\n        ref={canvasRef}\n        className=\"lava-lamp-canvas\"\n        width={window.innerWidth}\n        height={window.innerHeight}\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onMouseLeave={handleMouseUp}\n        onTouchStart={handleTouchStart}\n        onTouchMove={handleTouchMove}\n        onTouchEnd={handleTouchEnd}\n      />\n      <div className=\"lava-lamp-controls\">\n        <button\n          className=\"lava-lamp-button\"\n          onClick={toggleRunning}\n        >\n          {running ? \"⏸\" : \"▶\"}\n        </button>\n        <button\n          className=\"lava-lamp-button\"\n          onClick={reset}\n        >\n          ⟲\n        </button>\n      </div>\n    </div>\n  );\n}\n"],"names":["PARTICLE_COUNT","GRAVITY","BUOYANCY","FRICTION","HEAT_RATE","COOL_RATE","HEAT_CONDUCTION","HEAT_SOURCE_DISTANCE","COHESION_RADIUS","COHESION_STRENGTH","PARTICLE_RADIUS","PIXEL_SIZE","LavaLamp","canvasRef","useRef","animationFrameRef","particlesRef","running","setRunning","useState","mouseDownRef","mousePositionRef","x","y","initializeParticles","useCallback","width","window","innerWidth","height","innerHeight","particles","particlesPerClump","Math","floor","i","centerX","random","centerY","clumpHeat","j","angle","PI","dist","push","cos","sin","vx","vy","heat","length","useEffect","current","updateParticles","neighborCounts","map","p1","filter","p2","hypot","p","buoyancy","pow","distanceFromMouse","mouseHeatRadius","heatIntensity","distanceFromBottom","maxNeighbors","airExposure","min","max","dx","dy","force","fx","fy","conduction","render","canvas","ctx","getContext","fillStyle","fillRect","imageData","createImageData","data","influenceSum","heatSum","influence","r","g","b","py","yy","px","xx","idx","putImageData","animate","requestAnimationFrame","cancelAnimationFrame","handleResize","addEventListener","removeEventListener","handleMouseDown","e","clientX","clientY","handleMouseMove","handleMouseUp","handleTouchStart","touches","handleTouchMove","handleTouchEnd","toggleRunning","reset","_jsxs","className","children","_jsx","ref","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onTouchStart","onTouchMove","onTouchEnd","onClick"],"sourceRoot":""}